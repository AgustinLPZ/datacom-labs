ifndef::bound[]
:imagesdir: img
endif::[]

This lab is intended to give you an introduction to containers. We will be using Docker for this lab. For this lab, we will be deploying two containers in an AWS instance. This will include the install and deployment of containers via Docker. 
 
For the first part of this lab, it is important that you understand what a container is. Essentially, the deployment of an applicaiton can be a problematic endeavor. This is largely because as you deploy an application on one system, it is quite likely to not work on another -- due to the dependencies on one system to another. In short, all computer systems are not the same and deploying an application on one is likely different from another. 

Containers provide a highly 'containerized' environment that contains all of the necessary dependencies for an application to run. So when you deploy a container/application you can be confident that the application will run because it has been properly setup and will run on any computer that can run containers. A nice video is availble here that helps set up the difference Docker and the differentiation from virtualization: 

https://www.youtube.com/watch?v=JSLpG_spOBM&feature=youtu.be

.Docker & Containers
image::1.png[DockerContainers]

{nbsp} +
{nbsp} +

We are going to be setting up a Docker environment in AWS. So, like your last two labs, go ahead and setup an AWS instance that we can use for this lab. The one thing to note in this setup is that you need to setup a security group that enables SSH, HTTP, and TCP with port 8080. Everything else can stay with the default settings. You only need one instance running, mine is showing two -- just for my own practice purposes. 

.Set Security Group
image::2.png[Set Security Group]

{nbsp} +
{nbsp} +

.My Launched Instances
image::3.png[My Launched Instances]

{nbsp} +
{nbsp} +


After you've done this, keep the default setup and launch your machine. Again, create a unique key pair for each machine. Once you've launched the two machines (on different subnets), provide a picture of them in your EC2 dashboard that shows the two machines are on different subnets (Availability Zone). 

.Two Machines
image::ShowTwoMachinesTwoSubnets.png[TwoMachines]

{nbsp} +
{nbsp} +

Once both are launched, login to them (via two terminal windows). Once you have logged in, ping each machine. You should have no trouble if you set everything up correctly. 

.Login
image::LoginToEach.png[Login]

{nbsp} +
{nbsp} +

.Ping
image::PingEach.png[Ping]

{nbsp} +
{nbsp} +

Once you have successfully pinged the machines, go back to your EC2 dashboard and view your running instances. At the bottom, click the Monitoring tab. This shows you some administrative insight on the work your machines are doing. There is not going to be much here because we are only using these machines for pinging but Monitoring is a great way to see server load. 

.Monitoring
image::CloudWatch.png[Monitoring]

{nbsp} +
{nbsp} +

All right, now we are going to isolate one of the servers from the other. To do this, we are going to modify the inbound security rules that you set earlier. First, we have to note one of the security groups that one of the servers is associated with. Again, you should have two different security groups, one for each server. You'll see the assigned security group over on the right hand side of this picture (security group column). 

.Identify Security Group
image::IdentifySecurityGroup.png[Identify Security Group]

{nbsp} +
{nbsp} +

Once you've identified one of the security groups, note it down as this is the one we are going to change. Back at the EC2 Dashboard, on the left side, you'll see Security Groups under Network & Security. Click it. 

.Security Groups Link
image::SeeSecurityGroups.png[Security Groups Link]

{nbsp} +
{nbsp} +

From there, select the security group you are going to modify in order to restrict access across subnets. 

.Select Security Group to Modify
image::SelectOneSecurityGroup.png[Select Security Group to Modify]

{nbsp} +
{nbsp} +

After clicking the security group you are going to modify, click "Edit Inbound Rules". This will enable us to restrict what is coming into the server. 

.See Current Rules
image::SeeCurrentSecurityRules.png[See Current Rules]

{nbsp} +
{nbsp} +

.Edit Rules
image::EditRules.png[Edit Rules]

{nbsp} +
{nbsp} +

From there, you will modify the rule (simply click in the search box) to select the rule 0.0.0.0/32. Delete any additional ICMP rules. Make sure you don't delete your SSH rule. 

.Only CIDR 32
image::OnlyCIDR32.png[Only CIDR 32]

{nbsp} +
{nbsp} +

Go back to your terminals and show me that one of the machines can no longer be pinged (restricting pings only to the subnet). 

.BlockedPing
image:BlockedPing.png[BlockedPing]

{nbsp} +
{nbsp} +

Finally, go back to your EC2 Dashboard and click on the Key Pairs under Network & Security to show me the two key pairs you made for this lab. 

.Key Pairs
image::KeyPairs.png[Key Pairs]

{nbsp} +
{nbsp} +

Finally, finally... Go ahead and stop (or terminate) your servers. Also, if you are interested, take a look at your total AWS credits. You should see that they have barely been touched. 

QUESTION TO CONSIDER FOR THE FINAL: 

* Why did CIDR/32 work in this case? What is the block of numbers that could have pinged the machine with the modified inbound rule? 

* Now that you've seen a bit more of the Amazon AWS interface, describe some of the administrative power that you would have if you were using this technology to manage servers for people in your organizaion. 

